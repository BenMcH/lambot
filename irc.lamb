-- First we'll define some helper functions

map(f, []) -> [].
map(f, x::xs) -> f(x) :: map(f, xs).

fst((x, _)) -> x.

-- association list

-- insert a pair into a map
map_insert(assoc, key, value) -> (key, value) :: assoc.

-- lookup by key
map_lookup([], _) -> ("nothing").
map_lookup((k,v)::xs, key) ->
	if k == key then ("just", v)
	else map_lookup(xs, key).

-- remove a key from a map
map_remove([], key) -> [].
map_remove((k,v)::xs, key) ->
	if k == key then xs
	else (k,v) :: map_remove(xs, key).

-- irc stuff

-- Splits a string by spaces, or until it encounters a :, whereby the following is considered one element.
splitirc'("", stracc, acc) -> acc + [stracc].
splitirc'(" "::xs, stracc, acc) -> do
	splitirc'(xs, "", acc + [stracc])
end.
-- prefix message
splitirc'(":"::xs, _, acc) -> do
	acc + [xs]
end.
splitirc'(x::xs, stracc, acc) -> splitirc'(xs, stracc + x, acc).
-- helper function
splitirc(str) -> splitirc'(str, "", []).

-- (result, rest)
takeUntilSpace'(" "::xs, acc) -> (acc, xs).
takeUntilSpace'(x::xs, acc) -> takeUntilSpace'(xs, acc + x).
takeUntilSpace(str) -> takeUntilSpace'(str, "").

-- takes x!y and returns x
ircnick'("!"::xs, acc) -> acc.
ircnick'(x::xs, acc) -> ircnick'(xs, acc + x).
ircnick(str) -> ircnick'(str, "").

-- state stuff
initialState = ([]).

-- state getters
getFactoids(state) -> do
	(factoids) = state;
	factoids
end.

-- state setters
setFactoids(state, factoids) -> do
	(factoids)
end.

-- event handling

say(chan, msg) -> fputstr(sock, "PRIVMSG " + chan + " :" + msg + "\r\n").

handleMessage(s, nick, chan, "$factoids") -> do
	factoids = map(fst, getFactoids(s));
	say(chan, nick + ": " + repr(factoids));
	s
end.

handleMessage(s, nick, chan, "$defact "::line) -> do
	(k,v) = takeUntilSpace(line);
	factoids = getFactoids(s);
	say(chan, nick + ": defined " + k);
	setFactoids(s, map_insert(factoids, k, v))
end.

handleMessage(s, nick, chan, "$ping") -> do say(chan, nick + ": pong"); s end.
handleMessage(s, "darkf", chan, "$quit") -> do
	say(chan, "bye!");
	fputstr(sock, "QUIT\r\n");
	fclose(sock);
	s
end.
handleMessage(s, nick, chan, msg) -> s.

-- handleCommand(source, cmd, args)

handleCommand(s, _, "PING", [ping]) -> do
	putstrln("ping: " + ping);
	fputstr(sock, "PONG :" + ping);
	s
end.

handleCommand(s, user, "JOIN", [chan]) -> do
	putstrln("nick " + ircnick(user) + " joins " + chan);
	s
end.

handleCommand(s, user, "PRIVMSG", [chan, msg]) -> do
	nick = ircnick(user);
	putstrln(chan + " " + "<" + nick + "> " + msg);
	handleMessage(s, nick, chan, msg)
end.

-- nick list
handleCommand(s, _, "353", _::"="::chan::[nicks]) -> do
	-- nicks is space-separated
	putstrln("nicks in " + chan + ": " + nicks);
	s
end.

handleCommand(s, _, "372", [_,msg]) -> do putstrln("MOTD: " + msg); s end.
handleCommand(s, _, "422", [_,msg]) -> do putstrln(msg); s end. -- MOTD is missing

handleCommand(s, _, "251", _) -> s. -- There are X users and Y services on Z server(s)
handleCommand(s, _, "331", _) -> s. -- No topic is set
handleCommand(s, _, "366", _) -> s. -- End of NAMES list

handleCommand(s, src, cmd, args) -> do
	putstrln("Unhandled command: " + cmd + ", with args: " + repr(args) + " from " + src);
	s
end.

handleLine(s, ":" :: line) -> do
	-- sourced message
	(source, rest) = takeUntilSpace(line);
	command::args = splitirc(rest);
	handleCommand(s, source, command, args)
end.

handleLine(s, line) -> do
	-- non-sourced message
	command::args = splitirc(line);
	handleCommand(s, "", command, args)
end.

-- now for our actual program!

-- build our socket and connect to the server
sock = sockopen("127.0.0.1", 6667).

-- send introduction
fputstr(sock, "PASS foobar\r\n").
fputstr(sock, "NICK quaileggeater\r\n").
fputstr(sock, "USER fooname 0 * :Foo G. Bar\r\n").
fputstr(sock, "JOIN #TYBG\r\n").
fputstr(sock, "PRIVMSG #TYBG :sup.\r\n").

-- loop receiving lines
mainloop(state) ->
	if feof(sock) != true then
	do
		line = fgetline(sock);
		handleLine(state, line)
	end
	else
	  false.

putstrln("beginning mainloop").
loop(mainloop, initialState).
fclose(sock).
putstrln("done").